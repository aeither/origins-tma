#include "imports/stdlib.fc";

;; Storage structure:
;; next_invoice_id: int32 - auto-increment ID for invoices
;; invoice_count: int32 - total number of invoices
;; invoices: dict - dictionary storing invoices (invoice_id -> invoice_data)

;; Invoice structure (stored as cell):
;; invoice_id: uint32
;; description: uint64 (hash of description string)
;; amount: coins
;; wallet: address
;; paid: bool (1 bit)

;; Message opcodes
const op::add_invoice = 0x1;
const op::update_invoice = 0x2;

;; Load storage data
(int, int, cell) load_storage() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_uint(32), ;; next_invoice_id
        ds~load_uint(32), ;; invoice_count
        ds~load_dict()    ;; invoices dictionary
    );
}

;; Save storage data
() save_storage(int next_invoice_id, int invoice_count, cell invoices) impure inline {
    set_data(begin_cell()
        .store_uint(next_invoice_id, 32)
        .store_uint(invoice_count, 32)
        .store_dict(invoices)
        .end_cell());
}

;; Serialize invoice to cell
cell serialize_invoice(int invoice_id, int description, int amount, slice wallet, int paid) inline {
    return begin_cell()
        .store_uint(invoice_id, 32)
        .store_uint(description, 64)
        .store_coins(amount)
        .store_slice(wallet)
        .store_uint(paid, 1)
        .end_cell();
}

;; Deserialize invoice from cell
(int, int, int, slice, int) deserialize_invoice(cell invoice_cell) inline {
    slice cs = invoice_cell.begin_parse();
    return (
        cs~load_uint(32), ;; invoice_id
        cs~load_uint(64), ;; description
        cs~load_coins(),  ;; amount
        cs~load_msg_addr(), ;; wallet
        cs~load_uint(1)   ;; paid
    );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    ;; Ignore bounced messages
    if (flags & 1) {
        return ();
    }
    
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    
    (int next_invoice_id, int invoice_count, cell invoices) = load_storage();
    
    if (op == op::add_invoice) {
        ;; Add new invoice
        int description = in_msg_body~load_uint(64);
        int amount = in_msg_body~load_coins();
        slice wallet = in_msg_body~load_msg_addr();
        
        ;; Create invoice
        cell invoice_data = serialize_invoice(next_invoice_id, description, amount, wallet, 0);
        
        ;; Store in dictionary
        invoices~udict_set_ref(32, next_invoice_id, invoice_data);
        
        ;; Update storage
        save_storage(next_invoice_id + 1, invoice_count + 1, invoices);
        
        return ();
    }
    
    if (op == op::update_invoice) {
        ;; Update existing invoice
        int invoice_id = in_msg_body~load_uint(32);
        
        ;; Get invoice from dictionary
        (cell invoice_cell, int found?) = invoices.udict_get_ref?(32, invoice_id);
        throw_unless(404, found?);
        
        ;; Deserialize invoice
        (int id, int description, int amount, slice wallet, int paid) = deserialize_invoice(invoice_cell);
        
        ;; Update paid status
        cell updated_invoice = serialize_invoice(id, description, amount, wallet, 1);
        
        ;; Store back in dictionary
        invoices~udict_set_ref(32, invoice_id, updated_invoice);
        
        ;; Save storage
        save_storage(next_invoice_id, invoice_count, invoices);
        
        return ();
    }
    
    throw(0xffff); ;; Unknown operation
}

;; Get methods

;; Get invoice by ID
(int, int, int, slice, int) get_invoice(int invoice_id) method_id {
    (int next_invoice_id, int invoice_count, cell invoices) = load_storage();
    
    (cell invoice_cell, int found?) = invoices.udict_get_ref?(32, invoice_id);
    throw_unless(404, found?);
    
    return deserialize_invoice(invoice_cell);
}

;; Get all invoices (returns as a tuple of invoice data)
tuple get_all_invoices() method_id {
    (int next_invoice_id, int invoice_count, cell invoices) = load_storage();
    
    tuple result = empty_tuple();
    
    ;; Iterate through all possible invoice IDs from 0 to next_invoice_id-1
    int i = 0;
    while (i < next_invoice_id) {
        (cell invoice_cell, int found?) = invoices.udict_get_ref?(32, i);
        if (found?) {
            (int id, int description, int amount, slice wallet, int paid) = deserialize_invoice(invoice_cell);
            tuple invoice_tuple = empty_tuple();
            invoice_tuple~tpush(id);
            invoice_tuple~tpush(description);
            invoice_tuple~tpush(amount);
            invoice_tuple~tpush(wallet);
            invoice_tuple~tpush(paid);
            result~tpush(invoice_tuple);
        }
        i += 1;
    }
    
    return result;
}

;; Get invoice count
int get_invoice_count() method_id {
    (int next_invoice_id, int invoice_count, cell invoices) = load_storage();
    return invoice_count;
}

;; Get next invoice ID
int get_next_invoice_id() method_id {
    (int next_invoice_id, int invoice_count, cell invoices) = load_storage();
    return next_invoice_id;
}
